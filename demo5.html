<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fontsampler Auto Init â€” Universal Demo</title>
  <!-- Include fontsampler core -->
  <script src="https://nikita-kanarev.github.io/fontsampler.js"></script>
  <script src="https://nikita-kanarev.github.io/fontsampler-skin.js"></script>
  <link rel="stylesheet" href="https://nikita-kanarev.github.io/fontsampler-skin.css" />
  
  <style>
    /* Minimal styling */
    body { 
      font-family: monospace; 
      margin: 20px; 
      line-height: 1.4;
    }
    
    .fsx-section { 
      margin-bottom: 40px; 
      max-width: 1200px;
    }
    
    .fsx-title { 
      margin: 20px 0 10px 0; 
      font-size: 14px;
      font-weight: bold;
    }
    
    /* Named instances display */
    .fsx-instances { 
      margin: 20px 0;
      padding-top: 10px;
      border-top: 1px solid #ccc;
    }
    
    .fsx-instance-row {
      margin: 10px 0;
      display: flex;
      align-items: center;
    }
    
    .fsx-instance-label {
      width: 120px;
      font-size: 12px;
      flex-shrink: 0;
    }
    
    .fsx-instance-sample {
      font-size: 48px;
      margin-left: 10px;
      min-width: 200px;
    }
    
    /* Style testers */
    .fsx-style-item { 
      margin: 20px 0; 
    }
    
    .fsx-style-name { 
      font-size: 12px;
      margin: 5px 0; 
      font-weight: bold;
    }
    
    /* Error display */
    .fsx-error {
      color: red;
      border: 1px solid red;
      padding: 10px;
      margin: 10px 0;
      font-size: 12px;
    }

    [id^="name_"] .fsjs-control-group {
      display: none !important;
    }
  </style>
</head>
<body>

  <!-- Demo HTML Markup -->
  <!-- Multiple fonts can be used on the same page -->
  
  <div class="fsx-section">
    <h2>Name</h2>
    <div id="name_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
    <h2>Main Sampler</h2>
    <div id="main_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
    <h2>Sampler</h2>
    <div id="sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
    <h2>Styles Sampler</h2>    
    <div id="styles_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
  </div>

  <!-- You can add more fonts by creating more sections with different XXX identifiers -->
  <!--
  <div class="fsx-section">
    <h2 class="fsx-title">Another Font</h2>
    <div id="name_roboto" data-font="./fonts/roboto/RobotoFlex.woff2"></div>
    <div id="main_sampler_roboto" data-font="./fonts/roboto/RobotoFlex.woff2"></div>
    <div id="sampler_roboto" data-font="./fonts/roboto/RobotoFlex.woff2"></div>
    <div id="styles_sampler_roboto" data-font="./fonts/roboto/RobotoFlex.woff2"></div>
  </div>
  -->

  <!-- Auto Initializer Script -->
  <script>
  (function () {
    "use strict";

    /**
     * Universal Fontsampler Auto-Initializer
     * 
     * Automatically scans page for div elements matching these patterns:
     * - name_XXX: readonly name display
     * - main_sampler_XXX: single-line tester with axes/features + named instances
     * - sampler_XXX: multi-line tester with axes/features + size control
     * - styles_sampler_XXX: individual testers for each named instance
     * 
     * Supports multiple fonts on same page using different XXX identifiers.
     * Uses data-font attribute to specify font file path.
     * JSON metadata is inferred by changing font extension to .json
     */

    // ID patterns for different tester types
    const PATTERNS = {
      NAME: /^name_(.+)$/,
      MAIN: /^main_sampler_(.+)$/,
      MULTI: /^sampler_(.+)$/,
      STYLES: /^styles_sampler_(.+)$/
    };

    /**
     * Resolve JSON metadata URL from font URL
     * @param {string} fontUrl - Path to font file
     * @returns {string} Path to JSON metadata file
     */
    function resolveMetaUrl(fontUrl) {
      if (!fontUrl) return null;
      try {
        const url = new URL(fontUrl, document.baseURI);
        const pathname = url.pathname;
        const jsonPath = pathname.replace(/\.[^.]+$/, ".json");
        return url.origin + jsonPath + url.search + url.hash;
      } catch (e) {
        // Handle relative paths
        return fontUrl.replace(/\.[^.]+$/, ".json");
      }
    }

    /**
     * Fetch and parse JSON metadata with error handling
     * @param {string} metaUrl - URL to JSON metadata
     * @returns {Object} Parsed metadata or error object
     */
    async function loadMeta(metaUrl) {
      const fail = (msg) => ({ error: true, message: msg });
      
      if (!metaUrl) return fail("No metadata URL provided");
      
      try {
        const res = await fetch(metaUrl, { credentials: "same-origin" });
        if (!res.ok) return fail(`Failed to load metadata: ${res.status} ${res.statusText}`);
        
        const json = await res.json();
        if (!json || (!json.files && !Array.isArray(json.files))) {
          return fail("Invalid metadata: missing 'files' property");
        }
        
        // Normalize files to array format
        if (typeof json.files === 'string') {
          json.files = [json.files];
        }
        
        return json;
      } catch (err) {
        return fail(`Metadata fetch error: ${err.message || err}`);
      }
    }

    /**
     * Build fonts array for fontsampler
     * @param {Object} meta - Font metadata
     * @param {Object} instanceOverride - Specific named instance settings
     * @returns {Array} Fontsampler fonts configuration
     */
    function buildFonts(meta, instanceOverride = null) {
      const base = { 
        name: meta.name || "Unknown Font", 
        files: meta.files 
      };
      
      if (instanceOverride) {
        base.instance = instanceOverride;
      }
      
      return [base];
    }

    /**
     * Build fontsampler options configuration
     * @param {Object} meta - Font metadata
     * @param {Object} config - Configuration options
     * @returns {Object} Fontsampler options
     */
    function buildOptions(meta, {
      multiline = true,
      initialText = "",
      sizePx = 18,
      readonly = false,
      showSize = false
    } = {}) {
      
      const order = [];
      const config = {};

      // Content area (tester)
      order.push("tester");
      config.tester = { 
        editable: !readonly, 
        label: false 
      };

      // Size control (optional)
      if (showSize) {
        order.unshift(["fontsize"]);
        config.fontsize = { 
          unit: "px", 
          init: sizePx, 
          min: 8, 
          max: 256, 
          step: 1, 
          label: "Size" 
        };
      }

      // OpenType features
      if (Array.isArray(meta.features) && meta.features.length) {
        order.push(["opentype"]);
        config.opentype = { 
          choices: meta.features, 
          init: meta.features.includes('liga') ? ['liga'] : [], 
          label: "Features" 
        };
      }

      // Variable font axes
      if (Array.isArray(meta.axes) && meta.axes.length) {
        const axisRow = [];
        
        for (const axis of meta.axes) {
          const tag = axis.tag;
          axisRow.push(tag);
          
          config[tag] = {
            init: typeof axis.default === "number" ? axis.default : axis.min,
            min: axis.min,
            max: axis.max,
            step: axis.step || 1,
            label: axis.label || tag.toUpperCase()
          };
        }
        
        if (axisRow.length) {
          order.push(axisRow);
        }
      }

      return {
        initialText,
        multiline,
        lazyload: false,
        order,
        config,
        classes: { 
          rootClass: "fsjs-skin" 
        }
      };
    }

    /**
     * Display error message in container
     * @param {HTMLElement} node - Container element
     * @param {string} message - Error message
     */
    function showError(node, message) {
      const el = document.createElement("div");
      el.className = "fsx-error";
      el.setAttribute("role", "alert");
      el.textContent = `Error: ${message}`;
      node.appendChild(el);
    }

    /**
     * Create named instances display for main sampler
     * @param {HTMLElement} container - Parent container
     * @param {Array} instances - Named instances from metadata
     * @param {Object} meta - Font metadata
     */
    function createNamedInstancesDisplay(container, instances, meta) {
      if (!instances || !instances.length) return;
      
      const instancesContainer = document.createElement("div");
      instancesContainer.className = "fsx-instances";
      
      const title = document.createElement("div");
      title.textContent = "Named Instances:";
      title.style.cssText = "font-size: 12px; font-weight: bold; margin-bottom: 10px;";
      instancesContainer.appendChild(title);
      
      for (const inst of instances) {
        const row = document.createElement("div");
        row.className = "fsx-instance-row";
        
        const label = document.createElement("span");
        label.className = "fsx-instance-label";
        label.textContent = `${inst.name}:`;
        
        const sample = document.createElement("div");
        sample.className = "fsx-instance-sample";
        sample.textContent = "Type here";
        
        // Initialize with fontsampler for this specific instance
        const instanceOptions = buildOptions(meta, {
          multiline: false,
          initialText: "Type here",
          sizePx: 48,
          readonly: false,
          showSize: false
        });
        
        try {
          const fonts = buildFonts(meta, inst.instance);
          const fs = new Fontsampler(sample, fonts, instanceOptions);
          fs.init();
        } catch (err) {
          sample.textContent = `Error: ${err.message}`;
          sample.style.color = "red";
        }
        
        row.appendChild(label);
        row.appendChild(sample);
        instancesContainer.appendChild(row);
      }
      
      container.appendChild(instancesContainer);
    }

    /**
     * Initialize a single node based on its type
     * @param {HTMLElement} node - DOM element to initialize
     * @param {string} type - Type of tester (name|main|multi|styles)
     */
    async function initNode(node, type) {
      const fontUrl = node.getAttribute("data-font");
      if (!fontUrl) {
        showError(node, "Missing data-font attribute");
        return;
      }
      
      const metaUrl = node.getAttribute("data-meta") || resolveMetaUrl(fontUrl);
      const meta = await loadMeta(metaUrl);
      
      if (meta.error) {
        showError(node, meta.message);
        return;
      }

      try {
        switch (type) {
          case "name":
            // Readonly name display
            const nameOptions = buildOptions(meta, { 
              multiline: false, 
              initialText: meta.name || "Font Name", 
              sizePx: 48, 
              readonly: true,
              showSize: false 
            });
            
            const nameFs = new Fontsampler(node, buildFonts(meta), nameOptions);
            nameFs.init();
            break;

          case "main":
            // Main single-line sampler with named instances
            const mainOptions = buildOptions(meta, { 
              multiline: false, 
              initialText: "Type here", 
              sizePx: 80, 
              readonly: false,
              showSize: false 
            });
            
            const mainFs = new Fontsampler(node, buildFonts(meta), mainOptions);
            mainFs.init();
            
            // Add named instances display
            setTimeout(() => {
              createNamedInstancesDisplay(node, meta.instances, meta);
            }, 100);
            break;

          case "multi":
            // Multi-line tester with size control
            const multiOptions = buildOptions(meta, { 
              multiline: true, 
              initialText: "Multi-line text here...\nType more text to test the font.", 
              sizePx: 24, 
              readonly: false,
              showSize: true 
            });
            
            const multiFs = new Fontsampler(node, buildFonts(meta), multiOptions);
            multiFs.init();
            break;

          case "styles":
            // Individual testers for each named instance
            const instances = Array.isArray(meta.instances) ? meta.instances : [];
            
            if (!instances.length) {
              showError(node, "No named instances defined in metadata");
              return;
            }
            
            for (const inst of instances) {
              const wrapper = document.createElement("div");
              wrapper.className = "fsx-style-item";
              
              const label = document.createElement("div");
              label.className = "fsx-style-name";
              label.textContent = inst.name;
              
              const mount = document.createElement("div");
              
              wrapper.appendChild(label);
              wrapper.appendChild(mount);
              node.appendChild(wrapper);

              const styleOptions = buildOptions(meta, { 
                multiline: false, 
                initialText: inst.name, 
                sizePx: 32, 
                readonly: false,
                showSize: true 
              });
              
              const styleFs = new Fontsampler(mount, buildFonts(meta, inst.instance), styleOptions);
              styleFs.init();
            }
            break;
        }
      } catch (err) {
        showError(node, `Fontsampler initialization failed: ${err.message}`);
      }
    }

    /**
     * Scan DOM and initialize all matching elements
     */
    async function initAll() {
      const nodes = Array.from(document.querySelectorAll("div[id]"));
      const jobs = [];

      for (const node of nodes) {
        const id = node.id;
        
        if (PATTERNS.NAME.test(id)) {
          jobs.push(initNode(node, "name"));
        } else if (PATTERNS.MAIN.test(id)) {
          jobs.push(initNode(node, "main"));
        } else if (PATTERNS.MULTI.test(id)) {
          jobs.push(initNode(node, "multi"));
        } else if (PATTERNS.STYLES.test(id)) {
          jobs.push(initNode(node, "styles"));
        }
      }

      // Wait for all initializations to complete
      await Promise.allSettled(jobs);
    }

    // Start initialization when DOM is ready
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initAll);
    } else {
      initAll();
    }
  })();
  </script>

  <!-- 
  Example JSON metadata structure:
  Save as: Archaism.json (same name as font file but with .json extension)
  
  The original Archaism.json had a syntax error (extra comma). Here's the corrected version:
  
  {
    "name": "Archaism",
    "files": "https://nikita-kanarev.github.io/Archaism.woff2",
    "axes": [
      { "tag": "wdth", "min": 0, "max": 100, "default": 50, "step": 1, "label": "Width" },
      { "tag": "cntr", "min": 0, "max": 2, "default": 1, "step": 1, "label": "Contrast" }
    ],
    "features": ["liga", "dlig", "ss01", "onum"],
    "instances": [
      { "name": "Wd100Ct0", "instance": { "wdth": 100, "cntr": 0 } },
      { "name": "Wd500Ct2", "instance": { "wdth": 50, "cntr": 2 } },
      { "name": "Wd0Ct1", "instance": { "wdth": 0, "cntr": 1 } }
    ]
  }
  
  Note: The script now supports both formats:
  - "files": "single-file.woff2" (string)
  - "files": ["file1.woff2", "file2.woff"] (array)
  
  IMPORTANT: The original file had this error:
  "files": ["https://nikita-kanarev.github.io/Archaism.woff2",]  // <- extra comma
  
  Should be:
  "files": ["https://nikita-kanarev.github.io/Archaism.woff2"]   // <- no comma
  -->

</body>
</html>