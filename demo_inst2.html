<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fontsampler Auto Init — Universal Demo</title>

  <!-- Fontsampler core + skin -->
  <script src="https://nikita-kanarev.github.io/fontsampler.js"></script>
  <script src="https://nikita-kanarev.github.io/fontsampler-skin.js"></script>
  <link rel="stylesheet" href="https://nikita-kanarev.github.io/fontsampler-skin.css" />

  <style>
    body { font-family: monospace; margin: 20px; line-height: 1.4; }

    .fsx-section { margin-bottom: 40px; max-width: 1200px; }
    .fsx-title { margin: 20px 0 10px 0; font-size: 14px; font-weight: bold; }

    /* Named Instances под Main — сетка карточек */
    .fsx-instances {
      margin: 20px 0;
      padding-top: 10px;
      display: grid; /* убран !important, источник правды — CSS */
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 24px;
      align-items: end;
    }

    .fsx-instance-sample { width: 100%; text-align: center; }
    .fsx-instance-sample .fsjs-tester {
      white-space: nowrap;
      display: block;
      margin: 0 auto;
      line-height: 1;
    }

    /* Styles Sampler */
    .fsx-style-item { margin: 20px 0; }
    .fsx-style-name { font-size: 12px; margin: 5px 0; font-weight: bold; }

    /* Ошибки */
    .fsx-error { color: red; border: 1px solid red; padding: 10px; margin: 10px 0; font-size: 12px; }

    /* Name Sampler: убираем контролы и фиксируем размер (один источник — CSS) */
    [id^="name_"] .fsjs-control-group { display: none !important; }
    [id^="name_"] .fsjs-tester { font-size: 200px; line-height: 1; }

    /* Убираем контролы у карточек Named Instances под основным сэмплером */
    .fsx-instances .fsjs-control-fontsize,
    .fsx-instances .fsjs-control-opentype,
    .fsx-instances .fsjs-control-axis { display: none !important; }

    /* Только для Styles Sampler: нейтрализуем inline weight/style (источник — CSS) */
    [id^="styles_sampler_"] .fsjs-tester {
      font-style: initial !important;
      font-weight: initial !important;
    }
  </style>
</head>

<body>
  <div class="fsx-section">
    <h2>Name</h2>
    <div id="name_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>

    <h2>Main Sampler</h2>
    <div id="main_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>

    <h2>Sampler</h2>
    <div id="sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>

    <h2>Styles Sampler</h2>
    <div id="styles_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
  </div>

  <div class="fsx-section">
    <h2>Name</h2>
    <div id="name_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>

    <h2>Main Sampler</h2>
    <div id="main_sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>

    <h2>Sampler</h2>
    <div id="sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>

    <h2>Styles Sampler</h2>
    <div id="styles_sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>
  </div>

  <script>
    (function () {
      "use strict";

      const PATTERNS = {
        NAME:   /^name_(.+)$/,
        MAIN:   /^main_sampler_(.+)$/,
        MULTI:  /^sampler_(.+)$/,
        STYLES: /^styles_sampler_(.+)$/
      };

      function resolveMetaUrl(fontUrl) {
        if (!fontUrl) return null;
        try {
          const url = new URL(fontUrl, document.baseURI);
          const jsonPath = url.pathname.replace(/\.[^.]+$/, ".json");
          return url.origin + jsonPath + url.search + url.hash;
        } catch {
          return fontUrl.replace(/\.[^.]+$/, ".json");
        }
      }

      async function loadMeta(metaUrl) {
        const fail = (m) => ({ error: true, message: m });
        if (!metaUrl) return fail("No metadata URL provided");
        try {
          const res = await fetch(metaUrl, { credentials: "same-origin" });
          if (!res.ok) return fail(`Failed to load metadata: ${res.status} ${res.statusText}`);

          const json = await res.json();

          // Нормализация и строгая проверка files
          let files = json?.files;
          if (files == null) return fail("Invalid metadata: missing 'files' property");
          files = Array.isArray(files) ? files : [files];
          files = files.filter(f => typeof f === "string" && f.trim().length);
          if (!files.length) return fail("Invalid metadata: 'files' is empty");

          json.files = files;
          return json;
        } catch (err) {
          return fail(`Metadata fetch error: ${err?.message || err}`);
        }
      }

      function buildFonts(meta, instance = null) {
        if (instance?.file) {
          return [{ name: `${meta.name || "Font"} ${instance.name || ""}`.trim(), files: [instance.file] }];
        }
        return [{ name: meta.name || "Unknown Font", files: meta.files }];
      }

      function buildOptions(meta, {
        multiline = true, initialText = "", sizePx = 38, readonly = false,
        showSize = false, includeFeatures = true, includeAxes = true
      } = {}) {
        const order = [];
        const config = {};

        order.push("tester");
        config.tester = { editable: !readonly, label: false };

        if (showSize) {
          order.unshift(["fontsize"]);
          config.fontsize = { unit: "px", init: sizePx, min: 8, max: 256, step: 1, label: "Size" };
        }

        if (includeFeatures && Array.isArray(meta.features) && meta.features.length) {
          order.push(["opentype"]);
          config.opentype = {
            choices: meta.features,
            init: meta.features.includes("liga") ? ["liga"] : [],
            label: "Features"
          };
        }

        if (includeAxes && Array.isArray(meta.axes) && meta.axes.length) {
          const axisRow = [];
          for (const axis of meta.axes) {
            const tag = axis.tag;
            axisRow.push(tag);
            config[tag] = {
              init: (typeof axis.default === "number") ? axis.default : axis.min,
              min: axis.min, max: axis.max, step: axis.step || 1,
              label: axis.label || tag.toUpperCase()
            };
          }
          if (axisRow.length) order.push(axisRow);
        }

        return {
          initialText,
          multiline,
          lazyload: false,
          order,
          config,
          classes: { rootClass: "fsjs-skin" }
        };
      }

      function showError(node, message) {
        const el = document.createElement("div");
        el.className = "fsx-error";
        el.setAttribute("role", "alert");
        el.textContent = `Error: ${message}`;
        node.appendChild(el);
      }

      function createNamedInstancesDisplay(container, instances, meta) {
        if (!Array.isArray(instances) || !instances.length) return;

        const wrap = document.createElement("div");
        wrap.className = "fsx-instances"; // никаких inline-стилей — вся раскладка в CSS

        for (const inst of instances) {
          const sample = document.createElement("div");
          sample.className = "fsx-instance-sample";

          const options = {
            initialText: inst.name,
            multiline: false,
            lazyload: false,
            config: { tester: { editable: false, label: false } },
            order: ["tester"],
            classes: { rootClass: "fsjs-skin" }
          };

          try {
            const fs = new Fontsampler(sample, buildFonts(meta, inst), options);
            FontsamplerSkin(fs);
            fs.init();

            // на всякий — убираем возможные inline вес/стиль
            const testerEl = sample.querySelector(".fsjs-tester");
            if (testerEl) {
              testerEl.style.removeProperty("font-weight");
              testerEl.style.removeProperty("font-style");
            }
          } catch (err) {
            sample.textContent = `Error: ${err.message}`;
            sample.style.color = "red";
          }

          wrap.appendChild(sample);
        }

        container.appendChild(wrap);
      }

      async function initNode(node, type) {
        const fontUrl = node.getAttribute("data-font");
        if (!fontUrl) { showError(node, "Missing data-font attribute"); return; }

        const metaUrl = node.getAttribute("data-meta") || resolveMetaUrl(fontUrl);
        const meta = await loadMeta(metaUrl);
        if (meta.error) { showError(node, meta.message); return; }

        try {
          switch (type) {
            case "name": {
              const nameOptions = {
                initialText: meta.name || "Font Name",
                multiline: false,
                lazyload: false,
                config: { tester: { editable: false, label: false } },
                order: ["tester"],
                classes: { rootClass: "fsjs-skin" }
              };
              const fs = new Fontsampler(node, buildFonts(meta), nameOptions);
              FontsamplerSkin(fs);
              fs.init();
              break;
            }

            // case "main": {
            //   const mainOptions = buildOptions(meta, {
            //     multiline: false,
            //     initialText: meta.name || "Font Name",
            //     sizePx: 240,
            //     readonly: false,
            //     showSize: false,
            //     includeFeatures: true,
            //     includeAxes: true
            //   });
            //   const fs = new Fontsampler(node, buildFonts(meta), mainOptions);
            //   FontsamplerSkin(fs);
            //   fs.init();

            //   // отложим создание «Named Instances» на микротаску после init
            //   queueMicrotask(() => createNamedInstancesDisplay(node, meta.instances, meta));
            //   break;
            // }

            case "main": {
              const mainOptions = buildOptions(meta, {
              multiline: false,
              initialText: meta.name || "Font Name",
              showSize: false,
              includeFeatures: true,
              includeAxes: true
            });

            const fs = new Fontsampler(node, buildFonts(meta), mainOptions);
              FontsamplerSkin(fs);
              fs.init();

              // После инициализации элемент уже в DOM
              const testerEl = node.querySelector(".fsjs-tester");
              if (testerEl) {
                // Нормально (без !important):
                // testerEl.style.fontSize = "240px";
                // testerEl.style.lineHeight = "1";

                // Жёстко, если в CSS есть !important:
                testerEl.style.setProperty("font-size", "240px", "important");
                testerEl.style.setProperty("line-height", "1", "important");
              }

              queueMicrotask(() => createNamedInstancesDisplay(node, meta.instances, meta));
              break;
            }

            case "multi": {
              const multiOptions = buildOptions(meta, {
                multiline: true,
                initialText: "Multi-line text here...\nType more text to test the font.",
                sizePx: 240,
                readonly: false,
                showSize: true,
                includeFeatures: true,
                includeAxes: true
              });
              const fs = new Fontsampler(node, buildFonts(meta), multiOptions);
              FontsamplerSkin(fs);
              fs.init();
              break;
            }

            case "styles": {
              const instances = Array.isArray(meta.instances) ? meta.instances : [];
              if (!instances.length) { showError(node, "No named instances defined in metadata"); return; }

              for (const inst of instances) {
                const wrapper = document.createElement("div"); wrapper.className = "fsx-style-item";
                const label = document.createElement("div"); label.className = "fsx-style-name"; label.textContent = inst.name;
                const mount = document.createElement("div");
                wrapper.appendChild(label); wrapper.appendChild(mount); node.appendChild(wrapper);

                const styleOptions = buildOptions(meta, {
                  multiline: false,
                  initialText: inst.name,
                  sizePx: 96,
                  readonly: false,
                  showSize: true,
                  includeFeatures: false,
                  includeAxes: false
                });
                // никакого принудительного inline-стиля — полагаемся на CSS
                const fs = new Fontsampler(mount, buildFonts(meta, inst), styleOptions);
                FontsamplerSkin(fs);
                fs.init();
              }
              break;
            }
          }
        } catch (err) {
          showError(node, `Fontsampler initialization failed: ${err.message}`);
        }
      }

      async function initAll() {
        // Точечный подбор узлов под четыре шаблона id
        const nodes = document.querySelectorAll([
          'div[id^="name_"]',
          'div[id^="main_sampler_"]',
          'div[id^="sampler_"]',
          'div[id^="styles_sampler_"]'
        ].join(','));

        const jobs = [];
        for (const node of nodes) {
          const id = node.id;
          if (PATTERNS.NAME.test(id))  jobs.push(initNode(node, "name"));
          else if (PATTERNS.MAIN.test(id))  jobs.push(initNode(node, "main"));
          else if (PATTERNS.MULTI.test(id)) jobs.push(initNode(node, "multi"));
          else if (PATTERNS.STYLES.test(id)) jobs.push(initNode(node, "styles"));
        }
        await Promise.allSettled(jobs);
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initAll);
      } else {
        initAll();
      }
    })();
  </script>
</body>
</html>
