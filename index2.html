<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fontsampler Auto Init — Universal Demo</title>
  <!-- Include fontsampler core -->
  <script src="https://nikita-kanarev.github.io/fontsampler.js"></script>
  <script src="https://nikita-kanarev.github.io/fontsampler-skin.js"></script>
  <link rel="stylesheet" href="https://nikita-kanarev.github.io/fontsampler-skin.css" />

  <style>
    /* Minimal styling */
    body { 
      font-family: monospace; 
      margin: 20px; 
      line-height: 1.4;
    }

    .fsx-section { 
      margin-bottom: 40px; 
      max-width: 1200px;
    }

    .fsx-title { 
      margin: 20px 0 10px 0; 
      font-size: 14px;
      font-weight: bold;
    }

    /* Named instances display */
    .fsx-instances { 
      margin: 20px 0;
      padding-top: 10px;
      border-top: 1px solid #ccc;
    }

    .fsx-instance-row {
      margin: 10px 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .fsx-instance-label {
      width: 120px;
      font-size: 12px;
      flex-shrink: 0;
    }

    .fsx-instance-sample {
      font-size: 88px;  /* крупные мини-пробы */
      line-height: 1;
      margin-left: 10px;
      min-width: 200px;
    }

    /* важно: корень мини-инстанса в одну строку, чтобы не ломать флекс */
    .fsx-instance-row .fsjs-root { 
      display: inline-block; 
    }

    /* Style testers */
    .fsx-style-item { 
      margin: 20px 0; 
    }

    .fsx-style-name { 
      font-size: 12px;
      margin: 5px 0; 
      font-weight: bold;
    }

    /* Error display */
    .fsx-error {
      color: red;
      border: 1px solid red;
      padding: 10px;
      margin: 10px 0;
      font-size: 12px;
    }

    /* name_* — без контролов, фиксируем размер 220px */
    [id^="name_"] .fsjs-control-group { display: none !important; }
    [id^="name_"] .fsjs-tester { font-size: 220px; line-height: 1; }

    /* убрать контролы у мини-проб инстансов в блоке main_sampler_* (мы рендерим кастомно, но на всякий случай) */
    .fsx-instances .fsjs-control-fontsize,
    .fsx-instances .fsjs-control-opentype,
    .fsx-instances .fsjs-control-axis {
      display: none !important;
    }

    /* Стили для кастомного styles_sampler: только размер */
    .fsx-styles-root { border-top: 1px solid #ccc; padding-top: 10px; }
    .fsx-size-ctrl { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
    .fsx-size-ctrl label { font-size: 12px; }
    .fsx-style-row { margin: 14px 0; }
    .fsx-style-name { font-size: 12px; margin-bottom: 4px; font-weight: bold; }
    .fsx-style-sample { font-size: 32px; line-height: 1; letter-spacing: 0em; text-align: left; }
  </style>
</head>
<body>

  <!-- Demo HTML Markup -->
  <!-- Multiple fonts can be used on the same page -->

  <div class="fsx-section">

    <h2>Name</h2>
    <div id="name_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>

    <h2>Main Sampler</h2>
    <div id="main_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>

    <h2>Sampler</h2>
    <div id="sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>

    <h2>Styles Sampler</h2>    
    <div id="styles_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>

  </div>


  <div class="fsx-section">

    <h2>Name</h2>
    <div id="name_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>

    <h2>Main Sampler</h2>
    <div id="main_sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>

    <h2>Sampler</h2>
    <div id="sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>

    <h2>Styles Sampler</h2>    
    <div id="styles_sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>

  </div>

  <!-- Auto Initializer Script -->
  <script>
  (function () {
    "use strict";

    // ID patterns for different tester types
    const PATTERNS = {
      NAME: /^name_(.+)$/,
      MAIN: /^main_sampler_(.+)$/,
      MULTI: /^sampler_(.+)$/,
      STYLES: /^styles_sampler_(.+)$/
    };

    function resolveMetaUrl(fontUrl) {
      if (!fontUrl) return null;
      try {
        const url = new URL(fontUrl, document.baseURI);
        const pathname = url.pathname;
        const jsonPath = pathname.replace(/\.[^.]+$/, ".json");
        return url.origin + jsonPath + url.search + url.hash;
      } catch (e) {
        return fontUrl.replace(/\.[^.]+$/, ".json");
      }
    }

    async function loadMeta(metaUrl) {
      const fail = (msg) => ({ error: true, message: msg });
      if (!metaUrl) return fail("No metadata URL provided");
      try {
        const res = await fetch(metaUrl, { credentials: "same-origin" });
        if (!res.ok) return fail(\`Failed to load metadata: \${res.status} \${res.statusText}\`);
        const json = await res.json();
        if (!json || (!json.files && !Array.isArray(json.files))) {
          return fail("Invalid metadata: missing 'files' property");
        }
        if (typeof json.files === 'string') json.files = [json.files];
        return json;
      } catch (err) {
        return fail(\`Metadata fetch error: \${err.message || err}\`);
      }
    }

    function buildFonts(meta, instanceOverride = null) {
      const base = { 
        name: meta.name || "Unknown Font", 
        files: meta.files 
      };
      if (instanceOverride) base.instance = instanceOverride;
      return [base];
    }

    function buildOptions(
      meta,
      {
        multiline = true,
        initialText = "",
        sizePx = 38,
        readonly = false,
        showSize = false,
        includeFeatures = true,
        includeAxes = true
      } = {}
    ) {
      const order = [];
      const config = {};

      // Content area (tester)
      order.push("tester");
      config.tester = { editable: !readonly, label: false };

      // Size control (optional)
      if (showSize) {
        order.unshift(["fontsize"]);
        config.fontsize = { 
          unit: "px", init: sizePx, min: 8, max: 256, step: 1, label: "Size" 
        };
      }

      // OpenType features (optional)
      if (includeFeatures && Array.isArray(meta.features) && meta.features.length) {
        order.push(["opentype"]);
        config.opentype = { 
          choices: meta.features, 
          init: meta.features.includes('liga') ? ['liga'] : [], 
          label: "Features" 
        };
      }

      // Variable font axes (optional)
      if (includeAxes && Array.isArray(meta.axes) && meta.axes.length) {
        const axisRow = [];
        for (const axis of meta.axes) {
          const tag = axis.tag;
          axisRow.push(tag);
          config[tag] = {
            init: typeof axis.default === "number" ? axis.default : axis.min,
            min: axis.min,
            max: axis.max,
            step: axis.step || 1,
            label: axis.label || tag.toUpperCase()
          };
        }
        if (axisRow.length) order.push(axisRow);
      }

      return {
        initialText,
        multiline,
        lazyload: false,
        order,
        config,
        classes: { rootClass: "fsjs-skin" }
      };
    }

    // --- helpers: вариативные оси
    function instanceToVarSettings(instanceObj, omitTags = []) {
      if (!instanceObj) return "";
      return Object.entries(instanceObj)
        .filter(([tag]) => !omitTags.includes(tag))
        .map(([tag, value]) => \`'\${tag}' \${value}\`)
        .join(", ");
    }

    function applyInstanceAxes(el, instanceObj) {
      if (!el || !instanceObj) return;
      // wght — задаём через font-weight, чтобы он не был переопределён
      if ("wght" in instanceObj) {
        el.style.fontWeight = String(instanceObj.wght);
      } else {
        el.style.fontWeight = "normal";
      }
      // opsz — отключим авто-оптику, если задаём вручную
      if ("opsz" in instanceObj) {
        el.style.fontOpticalSizing = "none";
      }
      // Остальные оси применяем через font-variation-settings
      const omit = ["wght"]; // 'wght' задаём отдельным свойством
      const fvs = instanceToVarSettings(instanceObj, omit);
      if (fvs) {
        el.style.fontVariationSettings = fvs;
      } else {
        el.style.fontVariationSettings = "normal";
      }
    }

    async function ensureFontLoaded(meta) {
      // Загружаем первое указание файла самостоятельно, чтобы использовать семейство meta.name в кастомных блоках
      const src = Array.isArray(meta.files) ? meta.files[0] : meta.files;
      if (!src) return;
      try {
        const face = new FontFace(meta.name, \`url(\${src})\`);
        const loaded = await face.load();
        document.fonts.add(loaded);
      } catch (e) {
        // swallow
      }
    }

    function showError(node, message) {
      const el = document.createElement("div");
      el.className = "fsx-error";
      el.setAttribute("role", "alert");
      el.textContent = \`Error: \${message}\`;
      node.appendChild(el);
    }

    // --- Кастомный список инстансов для main_sampler_* (без Fontsampler внутри)
    function createNamedInstancesDisplay(container, instances, meta) {
      if (!instances || !instances.length) return;

      const instancesContainer = document.createElement("div");
      instancesContainer.className = "fsx-instances";

      const title = document.createElement("div");
      title.textContent = "Named Instances:";
      title.style.cssText = "font-size: 12px; font-weight: bold; margin-bottom: 10px;";
      instancesContainer.appendChild(title);

      for (const inst of instances) {
        const row = document.createElement("div");
        row.className = "fsx-instance-row";

        const label = document.createElement("span");
        label.className = "fsx-instance-label";
        label.textContent = \`\${inst.name}:\`;

        const sample = document.createElement("div");
        sample.className = "fsx-instance-sample";
        sample.textContent = inst.name;

        // применяем семейство и вариативные оси напрямую
        sample.style.fontFamily = meta.name || "sans-serif";
        applyInstanceAxes(sample, inst.instance);

        row.appendChild(label);
        row.appendChild(sample);
        instancesContainer.appendChild(row);
      }

      container.appendChild(instancesContainer);
    }

    // --- Кастомный styles_sampler_*: только контрол размера + список инстансов
    function renderStylesSampler(node, meta) {
      const root = document.createElement("div");
      root.className = "fsx-styles-root";

      // контрол размера
      const ctrl = document.createElement("div");
      ctrl.className = "fsx-size-ctrl";
      const label = document.createElement("label");
      label.textContent = "Size";
      const input = document.createElement("input");
      input.type = "range";
      input.min = "8";
      input.max = "256";
      input.step = "1";
      input.value = "32";
      const val = document.createElement("span");
      val.textContent = "32px";
      ctrl.appendChild(label);
      ctrl.appendChild(input);
      ctrl.appendChild(val);
      root.appendChild(ctrl);

      const instances = Array.isArray(meta.instances) ? meta.instances : [];
      if (!instances.length) {
        showError(node, "No named instances defined in metadata");
        node.appendChild(root);
        return;
      }

      // список инстансов
      const rows = [];
      for (const inst of instances) {
        const row = document.createElement("div");
        row.className = "fsx-style-row";

        const nameEl = document.createElement("div");
        nameEl.className = "fsx-style-name";
        nameEl.textContent = inst.name;

        const sample = document.createElement("div");
        sample.className = "fsx-style-sample";
        sample.textContent = inst.name;

        // напрямую применяем семейство и оси
        sample.style.fontFamily = meta.name || "sans-serif";
        applyInstanceAxes(sample, inst.instance);

        row.appendChild(nameEl);
        row.appendChild(sample);
        root.appendChild(row);
        rows.push(sample);
      }

      // изменение размера
      input.addEventListener("input", () => {
        const px = input.value + "px";
        val.textContent = px;
        rows.forEach(el => { el.style.fontSize = px; });
      });

      node.appendChild(root);
    }

    async function initNode(node, type) {
      const fontUrl = node.getAttribute("data-font");
      if (!fontUrl) { showError(node, "Missing data-font attribute"); return; }

      const metaUrl = node.getAttribute("data-meta") || resolveMetaUrl(fontUrl);
      const meta = await loadMeta(metaUrl);
      if (meta.error) { showError(node, meta.message); return; }

      try {
        switch (type) {
          case "name": {
            // Readonly name display (фикс. размер 220px через CSS)
            const nameOptions = {
              initialText: meta.name || "Font Name",
              multiline: false,
              lazyload: false,
              config: { tester: { editable: false, label: false } },
              order: ["tester"],
              classes: { rootClass: "fsjs-skin" }
            };
            const nameFs = new Fontsampler(node, buildFonts(meta), nameOptions);
            FontsamplerSkin(nameFs);
            nameFs.init();
            // на всякий случай — нормальный вес
            const tester = node.querySelector(".fsjs-tester");
            if (tester) tester.style.fontWeight = "normal";
            await ensureFontLoaded(meta);
            break;
          }

          case "main": {
            const mainOptions = buildOptions(meta, { 
              multiline: false, 
              initialText: "Type here", 
              sizePx: 180, 
              readonly: false,
              showSize: false,
              includeFeatures: true,
              includeAxes: true
            });
            const mainFs = new Fontsampler(node, buildFonts(meta), mainOptions);
            FontsamplerSkin(mainFs);
            mainFs.init();
            await ensureFontLoaded(meta);
            // Кастомный список инстансов без Fontsampler внутри
            setTimeout(() => {
              createNamedInstancesDisplay(node, meta.instances, meta);
            }, 100);
            break;
          }

          case "multi": {
            const multiOptions = buildOptions(meta, { 
              multiline: true, 
              initialText: "Multi-line text here...\nType more text to test the font.", 
              sizePx: 24, 
              readonly: false,
              showSize: true,
              includeFeatures: true,
              includeAxes: true
            });
            const multiFs = new Fontsampler(node, buildFonts(meta), multiOptions);
            FontsamplerSkin(multiFs);
            multiFs.init();
            await ensureFontLoaded(meta);
            break;
          }

          case "styles": {
            // Полностью кастомный рендер: только размер, инстансы применяются напрямую, без Fontsampler.
            await ensureFontLoaded(meta);
            renderStylesSampler(node, meta);
            break;
          }
        }
      } catch (err) {
        showError(node, \`Fontsampler initialization failed: \${err.message}\`);
      }
    }

    async function initAll() {
      const nodes = Array.from(document.querySelectorAll("div[id]"));
      const jobs = [];

      for (const node of nodes) {
        const id = node.id;
        if (PATTERNS.NAME.test(id)) {
          jobs.push(initNode(node, "name"));
        } else if (PATTERNS.MAIN.test(id)) {
          jobs.push(initNode(node, "main"));
        } else if (PATTERNS.MULTI.test(id)) {
          jobs.push(initNode(node, "multi"));
        } else if (PATTERNS.STYLES.test(id)) {
          jobs.push(initNode(node, "styles"));
        }
      }
      await Promise.allSettled(jobs);
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initAll);
    } else {
      initAll();
    }
  })();
  </script>

  <!-- 
  Пример JSON:
  {
    "name": "Archaism",
    "files": "https://nikita-kanarev.github.io/Archaism.woff2",
    "axes": [
      { "tag": "wdth", "min": 0, "max": 100, "default": 50, "step": 1, "label": "Width" },
      { "tag": "cntr", "min": 0, "max": 2, "default": 1, "step": 1, "label": "Contrast" }
    ],
    "features": ["liga", "dlig", "ss01", "onum"],
    "instances": [
      { "name": "Wd100Ct0", "instance": { "wdth": 100, "cntr": 0 } },
      { "name": "Wd500Ct2", "instance": { "wdth": 50, "cntr": 2 } },
      { "name": "Wd0Ct1", "instance": { "wdth": 0, "cntr": 1 } }
    ]
  }
  -->
</body>
</html>
