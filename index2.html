<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fontsampler Auto Init — Universal Demo (Explicit Variations) — FIX2</title>
  <script src="https://nikita-kanarev.github.io/fontsampler.js"></script>
  <script src="https://nikita-kanarev.github.io/fontsampler-skin.js"></script>
  <link rel="stylesheet" href="https://nikita-kanarev.github.io/fontsampler-skin.css" />
  <style>
    body { font-family: monospace; margin: 20px; line-height: 1.4; }
    .fsx-section { margin-bottom: 40px; max-width: 1200px; }
    .fsx-instances { margin: 20px 0; padding-top: 10px; border-top: 1px solid #ccc; }
    .fsx-instance-row { margin: 10px 0; display: flex; align-items: center; gap: 10px; }
    .fsx-instance-label { width: 120px; font-size: 12px; flex-shrink: 0; }
    .fsx-instance-sample { font-size: 88px; line-height: 1; margin-left: 10px; min-width: 200px; }
    .fsx-instance-row .fsjs-root { display: inline-block; }
    .fsx-styles-toolbar { display: flex; align-items: center; gap: 12px; padding: 8px 0 12px; border-bottom: 1px dashed #ddd; margin-bottom: 12px; font-size: 12px; }
    .fsx-style-item { margin: 20px 0; }
    .fsx-style-name { font-size: 12px; margin: 5px 0; font-weight: bold; }
    .fsx-style-sample { line-height: 1; letter-spacing: 0; text-align: left; }
    .fsx-error { color: red; border: 1px solid red; padding: 10px; margin: 10px 0; font-size: 12px; }
    [id^="name_"] .fsjs-control-group { display: none !important; }
    [id^="name_"] .fsjs-tester { font-size: 220px; line-height: 1; }
    .fsx-instances .fsjs-control-fontsize,
    .fsx-instances .fsjs-control-opentype,
    .fsx-instances .fsjs-control-axis { display: none !important; }
  </style>
</head>
<body>
  <div class="fsx-section">
    <h2>Name</h2>
    <div id="name_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
    <h2>Main Sampler</h2>
    <div id="main_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
    <h2>Sampler</h2>
    <div id="sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
    <h2>Styles Sampler</h2>    
    <div id="styles_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
  </div>
  <div class="fsx-section">
    <h2>Name</h2>
    <div id="name_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>
    <h2>Main Sampler</h2>
    <div id="main_sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>
    <h2>Sampler</h2>
    <div id="sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>
    <h2>Styles Sampler</h2>    
    <div id="styles_sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>
  </div>
  
  <script>
  (function () {
    "use strict";

    const PATTERNS = {
      NAME: /^name_(.+)$/,
      MAIN: /^main_sampler_(.+)$/,
      MULTI: /^sampler_(.+)$/,
      STYLES: /^styles_sampler_(.+)$/
    };

    function resolveMetaUrl(fontUrl) {
      if (!fontUrl) return null;
      try {
        const url = new URL(fontUrl, document.baseURI);
        const pathname = url.pathname;
        const jsonPath = pathname.replace(/\.[^.]+$/, ".json");
        return url.origin + jsonPath + url.search + url.hash;
      } catch (e) {
        return fontUrl.replace(/\.[^.]+$/, ".json");
      }
    }

    async function loadMeta(metaUrl) {
      const fail = (msg) => ({ error: true, message: msg });
      if (!metaUrl) return fail("No metadata URL provided");
      try {
        const res = await fetch(metaUrl, { credentials: "same-origin" });
        if (!res.ok) return fail(`Failed to load metadata: ${res.status} ${res.statusText}`);
        const json = await res.json();
        if (!json || (!json.files && !Array.isArray(json.files))) {
          return fail("Invalid metadata: missing 'files' property");
        }
        if (typeof json.files === 'string') json.files = [json.files];
        return json;
      } catch (err) {
        return fail(`Metadata fetch error: ${err.message || err}`);
      }
    }

    function buildFonts(meta, instanceOverride = null) {
      const base = { name: meta.name || "Unknown Font", files: meta.files };
      if (instanceOverride) base.instance = instanceOverride;
      return [base];
    }

    function buildOptions(
      meta,
      {
        multiline = true,
        initialText = "",
        sizePx = 38,
        readonly = false,
        showSize = false,
        includeFeatures = true,
        includeAxes = true
      } = {}
    ) {
      const order = [];
      const config = {};
      order.push("tester");
      config.tester = { editable: !readonly, label: false };

      if (showSize) {
        order.unshift(["fontsize"]);
        config.fontsize = { unit: "px", init: sizePx, min: 8, max: 256, step: 1, label: "Size" };
      }

      if (includeFeatures && Array.isArray(meta.features) && meta.features.length) {
        order.push(["opentype"]);
        config.opentype = { choices: meta.features, init: meta.features.includes('liga') ? ['liga'] : [], label: "Features" };
      }

      if (includeAxes && Array.isArray(meta.axes) && meta.axes.length) {
        const axisRow = [];
        for (const axis of meta.axes) {
          const tag = axis.tag;
          axisRow.push(tag);
          config[tag] = {
            init: typeof axis.default === "number" ? axis.default : axis.min,
            min: axis.min,
            max: axis.max,
            step: axis.step || 1,
            label: axis.label || tag.toUpperCase()
          };
        }
        if (axisRow.length) order.push(axisRow);
      }

      return {
        initialText,
        multiline,
        lazyload: false,
        order,
        config,
        classes: { rootClass: "fsjs-skin" }
      };
    }

    function instanceToVarSettings(instanceObj) {
      if (!instanceObj) return "";
      return Object.entries(instanceObj)
        .map(([tag, value]) => `'${tag}' ${value}`)
        .join(", ");
    }

    function showError(node, message) {
      const el = document.createElement("div");
      el.className = "fsx-error";
      el.setAttribute("role", "alert");
      el.textContent = `Error: ${message}`;
      node.appendChild(el);
    }

    async function ensureFontLoaded(meta) {
      try {
        const loads = (meta.files || []).map(async (url) => {
          const ff = new FontFace(meta.name, `url(${url})`);
          const loaded = await ff.load();
          document.fonts.add(loaded);
        });
        await Promise.all(loads);
      } catch (e) {
        console.warn("FontFace load warning:", e);
      }
    }

    function createNamedInstancesDisplay(container, instances, meta) {
      if (!instances || !instances.length) return;
      const instancesContainer = document.createElement("div");
      instancesContainer.className = "fsx-instances";
      const title = document.createElement("div");
      title.textContent = "Named Instances:";
      title.style.cssText = "font-size: 12px; font-weight: bold; margin-bottom: 10px;";
      instancesContainer.appendChild(title);
      
      for (const inst of instances) {
        const row = document.createElement("div");
        row.className = "fsx-instance-row";
        
        const label = document.createElement("span");
        label.className = "fsx-instance-label";
        label.textContent = `${inst.name}:`;
        
        const sample = document.createElement("div");
        sample.className = "fsx-instance-sample";

        const instanceOptions = {
          initialText: inst.name,
          multiline: false,
          lazyload: false,
          config: { tester: { editable: false, label: false } },
          order: ["tester"],
          classes: { rootClass: "fsjs-skin" }
        };
        
        try {
          const fonts = buildFonts(meta, inst.instance);
          const fs = new Fontsampler(sample, fonts, instanceOptions);
          FontsamplerSkin(fs);
          fs.init();

          const root = sample.querySelector(".fsjs-root");
          if (root) root.style.display = "inline-block";
        } catch (err) {
          sample.textContent = `Error: ${err.message}`;
          sample.style.color = "red";
        }
        
        row.appendChild(label);
        row.appendChild(sample);
        instancesContainer.appendChild(row);
      }
      
      container.appendChild(instancesContainer);
    }

    async function initNode(node, type) {
      const fontUrl = node.getAttribute("data-font");
      if (!fontUrl) { showError(node, "Missing data-font attribute"); return; }
      
      const metaUrl = node.getAttribute("data-meta") || resolveMetaUrl(fontUrl);
      const meta = await loadMeta(metaUrl);
      if (meta.error) { showError(node, meta.message); return; }

      try {
        switch (type) {
          case "name": {
            const nameOptions = {
              initialText: meta.name || "Font Name",
              multiline: false,
              lazyload: false,
              config: { tester: { editable: false, label: false } },
              order: ["tester"],
              classes: { rootClass: "fsjs-skin" }
            };
            const nameFs = new Fontsampler(node, buildFonts(meta), nameOptions);
            FontsamplerSkin(nameFs);
            nameFs.init();
            const tester = node.querySelector(".fsjs-tester");
            if (tester) tester.style.fontWeight = "normal";
            break;
          }

          case "main": {
            const mainOptions = buildOptions(meta, { 
              multiline: false, 
              initialText: "Type here", 
              sizePx: 180, 
              readonly: false,
              showSize: false,
              includeFeatures: true,
              includeAxes: true
            });
            const mainFs = new Fontsampler(node, buildFonts(meta), mainOptions);
            FontsamplerSkin(mainFs);
            mainFs.init();
            setTimeout(() => {
              createNamedInstancesDisplay(node, meta.instances, meta);
            }, 100);
            break;
          }

          case "multi": {
            const multiOptions = buildOptions(meta, { 
              multiline: true, 
              initialText: "Multi-line text here...
Type more text to test the font.", 
              sizePx: 24, 
              readonly: false,
              showSize: true,
              includeFeatures: true,
              includeAxes: true
            });
            const multiFs = new Fontsampler(node, buildFonts(meta), multiOptions);
            FontsamplerSkin(multiFs);
            multiFs.init();
            break;
          }

          case "styles": {
            await ensureFontLoaded(meta);

            const instances = Array.isArray(meta.instances) ? meta.instances : [];
            if (!instances.length) { showError(node, "No named instances defined in metadata"); return; }

            const toolbar = document.createElement("div");
            toolbar.className = "fsx-styles-toolbar";
            const label = document.createElement("label");
            label.textContent = "Size";
            label.setAttribute("for", node.id + "_size");
            const slider = document.createElement("input");
            slider.type = "range";
            slider.min = "8";
            slider.max = "256";
            slider.step = "1";
            slider.value = "32";
            slider.id = node.id + "_size";
            const val = document.createElement("span");
            val.textContent = slider.value + "px";
            toolbar.appendChild(label);
            toolbar.appendChild(slider);
            toolbar.appendChild(val);
            node.appendChild(toolbar);

            const samples = [];
            slider.addEventListener("input", () => {
              val.textContent = slider.value + "px";
              for (const s of samples) s.style.fontSize = slider.value + "px";
            });

            for (const inst of instances) {
              const wrapper = document.createElement("div");
              wrapper.className = "fsx-style-item";
              
              const nameEl = document.createElement("div");
              nameEl.className = "fsx-style-name";
              nameEl.textContent = inst.name;
              
              const sample = document.createElement("div");
              sample.className = "fsx-style-sample";
              sample.textContent = inst.name;

              sample.style.fontFamily = meta.name || "inherit";
              sample.style.fontSize = slider.value + "px";
              sample.style.fontWeight = "normal";
              sample.style.fontStyle = "normal";
              sample.style.fontStretch = "normal";
              const fv = instanceToVarSettings(inst.instance);
              if (fv) sample.style.fontVariationSettings = fv;

              wrapper.appendChild(nameEl);
              wrapper.appendChild(sample);
              node.appendChild(wrapper);
              samples.push(sample);
            }
            break;
          }
        }
      } catch (err) {
        showError(node, `Fontsampler initialization failed: ${err.message}`);
      }
    }

    async function initAll() {
      const nodes = Array.from(document.querySelectorAll("div[id]"));
      const jobs = [];

      for (const node of nodes) {
        const id = node.id;
        if (PATTERNS.NAME.test(id)) jobs.push(initNode(node, "name"));
        else if (PATTERNS.MAIN.test(id)) jobs.push(initNode(node, "main"));
        else if (PATTERNS.MULTI.test(id)) jobs.push(initNode(node, "multi"));
        else if (PATTERNS.STYLES.test(id)) jobs.push(initNode(node, "styles"));
      }
      await Promise.allSettled(jobs);
    }

    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", initAll);
    else initAll();
  })();
  </script>
</body>
</html>
