<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fontsampler Auto Init — Fixed</title>

  <script src="https://nikita-kanarev.github.io/fontsampler.js"></script>
  <script src="https://nikita-kanarev.github.io/fontsampler-skin.js"></script>
  <link rel="stylesheet" href="https://nikita-kanarev.github.io/fontsampler-skin.css" />

  <style>
    body { font-family: monospace; margin: 20px; line-height: 1.4; }
    .fsx-section { margin-bottom: 40px; max-width: 1200px; }

    /* NAME: без контролов, размер строго 220px */
    [id^="name_"] .fsjs-control-group { display: none !important; }
    [id^="name_"] .fsjs-tester { font-size: 220px !important; line-height: 1; }

    /* Named Instances (внутри main_sampler_*) */
    .fsx-instances { margin: 20px 0; padding-top: 10px; border-top: 1px solid #ccc; }
    .fsx-instance-row { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
    .fsx-instance-label { width: 120px; font-size: 12px; flex-shrink: 0; }
    .fsx-instance-sample .fsjs-root { display: inline-block; }
    .fsx-instance-sample .fsjs-tester { font-size: 88px; line-height: 1; }

    /* Styles Sampler: по строке — слайдер + образец */
    .fsx-style-item { margin: 16px 0; }
    .fsx-style-head { display: flex; align-items: center; gap: 10px; font-size: 12px; margin-bottom: 6px; }
    .fsx-style-size { display: inline-flex; align-items: center; gap: 8px; }
    .fsx-style-size input[type="range"] { width: 220px; }
    .fsx-style-name { font-weight: bold; }
    .fsx-style-sample { line-height: 1; letter-spacing: 0; text-align: left; }

    /* прячем лишние контролы в мини-пробах инстансов */
    .fsx-instances .fsjs-control-fontsize,
    .fsx-instances .fsjs-control-opentype,
    .fsx-instances .fsjs-control-axis { display: none !important; }

    .fsx-error { color: red; border: 1px solid red; padding: 10px; margin: 10px 0; font-size: 12px; }
  </style>
</head>
<body>
  <div class="fsx-section">
    <h2>Name</h2>
    <div id="name_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>

    <h2>Main Sampler</h2>
    <div id="main_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>

    <h2>Sampler</h2>
    <div id="sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>

    <h2>Styles Sampler</h2>
    <div id="styles_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
  </div>

  <div class="fsx-section">
    <h2>Name</h2>
    <div id="name_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>

    <h2>Main Sampler</h2>
    <div id="main_sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>

    <h2>Sampler</h2>
    <div id="sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>

    <h2>Styles Sampler</h2>
    <div id="styles_sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>
  </div>

  <script>
  (function(){
    "use strict";

    const PATTERNS = {
      NAME: /^name_(.+)$/,
      MAIN: /^main_sampler_(.+)$/,
      MULTI: /^sampler_(.+)$/,
      STYLES: /^styles_sampler_(.+)$/
    };

    function resolveMetaUrl(fontUrl){
      if(!fontUrl) return null;
      try {
        const url = new URL(fontUrl, document.baseURI);
        return url.origin + url.pathname.replace(/\.[^.]+$/, ".json") + url.search + url.hash;
      } catch(e){
        return fontUrl.replace(/\.[^.]+$/, ".json");
      }
    }

    async function loadMeta(metaUrl){
      const fail = (m)=>({error:true,message:m});
      if(!metaUrl) return fail("No metadata URL provided");
      try{
        const res = await fetch(metaUrl, { credentials: "same-origin" });
        if(!res.ok) return fail(`Failed to load metadata: ${res.status} ${res.statusText}`);
        const json = await res.json();
        if(!json || (!json.files && !Array.isArray(json.files))) return fail("Invalid metadata: missing 'files' property");
        if(typeof json.files === "string") json.files = [json.files];
        return json;
      }catch(err){
        return fail(`Metadata fetch error: ${err.message || err}`);
      }
    }

    function buildFonts(meta, instanceOverride=null){
      const base = { name: meta.name || "Unknown Font", files: meta.files };
      if(instanceOverride) base.instance = instanceOverride;
      return [base];
    }

    function buildOptions(meta, {
      multiline=true,
      initialText="",
      sizePx=38,
      readonly=false,
      showSize=false,
      includeFeatures=true,
      includeAxes=true
    } = {}){
      const order = [];
      const config = {};

      order.push("tester");
      config.tester = { editable: !readonly, label: false };

      if(showSize){
        order.unshift(["fontsize"]);
        config.fontsize = { unit:"px", init:sizePx, min:8, max:256, step:1, label:"Size" };
      }

      if(includeFeatures && Array.isArray(meta.features) && meta.features.length){
        order.push(["opentype"]);
        config.opentype = { choices: meta.features, init: meta.features.includes("liga")?["liga"]:[], label:"Features" };
      }

      if(includeAxes && Array.isArray(meta.axes) && meta.axes.length){
        const axisRow = [];
        for(const axis of meta.axes){
          const tag = axis.tag;
          axisRow.push(tag);
          config[tag] = {
            init: typeof axis.default === "number" ? axis.default : axis.min,
            min: axis.min, max: axis.max, step: axis.step || 1,
            label: axis.label || tag.toUpperCase()
          };
        }
        if(axisRow.length) order.push(axisRow);
      }

      return { initialText, multiline, lazyload:false, order, config, classes:{ rootClass:"fsjs-skin" } };
    }

    const varString = (instObj)=>
      instObj ? Object.entries(instObj).map(([t,v])=>`'${t}' ${v}`).join(", ") : "";

    function showError(node,msg){
      const el = document.createElement("div");
      el.className = "fsx-error";
      el.textContent = `Error: ${msg}`;
      node.appendChild(el);
    }

    function createNamedInstancesDisplay(container, instances, meta){
      if(!instances || !instances.length) return;
      const box = document.createElement("div");
      box.className = "fsx-instances";
      const title = document.createElement("div");
      title.textContent = "Named Instances:";
      title.style.cssText = "font-size:12px;font-weight:bold;margin-bottom:10px;";
      box.appendChild(title);

      for(const inst of instances){
        const row = document.createElement("div");
        row.className = "fsx-instance-row";

        const label = document.createElement("span");
        label.className = "fsx-instance-label";
        label.textContent = `${inst.name}:`;

        const sample = document.createElement("div");
        sample.className = "fsx-instance-sample";

        const opts = {
          initialText: inst.name,
          multiline:false, lazyload:false,
          config:{ tester:{ editable:false, label:false } },
          order:["tester"], classes:{ rootClass:"fsjs-skin" }
        };

        try{
          const fs = new Fontsampler(sample, buildFonts(meta, inst.instance), opts);
          FontsamplerSkin(fs);
          fs.init();
          // ЯВНО: применяем вариативные оси и убираем CSS weight
          const t = sample.querySelector(".fsjs-tester");
          if(t){
            t.style.fontVariationSettings = varString(inst.instance);
            t.style.fontWeight = "normal";
          }
        }catch(err){
          sample.textContent = `Error: ${err.message}`;
          sample.style.color = "red";
        }

        row.appendChild(label);
        row.appendChild(sample);
        box.appendChild(row);
      }

      container.appendChild(box);
    }

    async function initNode(node, type){
      const fontUrl = node.getAttribute("data-font");
      if(!fontUrl) { showError(node, "Missing data-font attribute"); return; }

      const metaUrl = node.getAttribute("data-meta") || resolveMetaUrl(fontUrl);
      const meta = await loadMeta(metaUrl);
      if(meta.error){ showError(node, meta.message); return; }

      try{
        switch(type){
          case "name": {
            const opts = {
              initialText: meta.name || "Font Name",
              multiline:false, lazyload:false,
              config:{ tester:{ editable:false, label:false } },
              order:["tester"], classes:{ rootClass:"fsjs-skin" }
            };
            const fs = new Fontsampler(node, buildFonts(meta), opts);
            FontsamplerSkin(fs);
            fs.init();
            const t = node.querySelector(".fsjs-tester");
            if(t){ t.style.fontSize = "220px"; t.style.lineHeight = "1"; t.style.fontWeight = "normal"; }
            break;
          }

          case "main": {
            const opts = buildOptions(meta, {
              multiline:false, initialText:"Type here", sizePx:180,
              readonly:false, showSize:false, includeFeatures:true, includeAxes:true
            });
            const fs = new Fontsampler(node, buildFonts(meta), opts);
            FontsamplerSkin(fs);
            fs.init();
            setTimeout(()=>createNamedInstancesDisplay(node, meta.instances, meta), 100);
            break;
          }

          case "multi": {
            const opts = buildOptions(meta, {
              multiline:true,
              initialText:`Multi-line text here...\nType more text to test the font.`,
              sizePx:24, readonly:false, showSize:true, includeFeatures:true, includeAxes:true
            });
            const fs = new Fontsampler(node, buildFonts(meta), opts);
            FontsamplerSkin(fs);
            fs.init();
            break;
          }

          case "styles": {
            const instances = Array.isArray(meta.instances) ? meta.instances : [];
            if(!instances.length){ showError(node,"No named instances defined in metadata"); return; }

            // по каждой строке — свой слайдер размера + sample
            for(const inst of instances){
              const item = document.createElement("div");
              item.className = "fsx-style-item";

              const head = document.createElement("div");
              head.className = "fsx-style-head";

              const nameEl = document.createElement("div");
              nameEl.className = "fsx-style-name";
              nameEl.textContent = inst.name;

              const sizeWrap = document.createElement("label");
              sizeWrap.className = "fsx-style-size";
              sizeWrap.textContent = "Size";
              const slider = document.createElement("input");
              slider.type = "range"; slider.min="8"; slider.max="256"; slider.step="1"; slider.value="32";
              const szVal = document.createElement("span"); szVal.textContent = "32px";
              sizeWrap.appendChild(slider); sizeWrap.appendChild(szVal);

              head.appendChild(nameEl);
              head.appendChild(sizeWrap);

              const sample = document.createElement("div");
              sample.className = "fsx-style-sample";
              sample.textContent = inst.name;
              sample.style.fontFamily = meta.name || "inherit";
              sample.style.fontSize = "32px";
              sample.style.fontWeight = "normal";
              sample.style.fontStyle = "normal";
              sample.style.fontStretch = "normal";
              sample.style.fontVariationSettings = varString(inst.instance);

              slider.addEventListener("input", ()=>{
                sample.style.fontSize = slider.value + "px";
                szVal.textContent = slider.value + "px";
              });

              item.appendChild(head);
              item.appendChild(sample);
              node.appendChild(item);
            }
            break;
          }
        }
      }catch(err){
        showError(node, `Fontsampler initialization failed: ${err.message}`);
      }
    }

    async function initAll(){
      const nodes = Array.from(document.querySelectorAll("div[id]"));
      const jobs = [];
      for(const n of nodes){
        const id = n.id;
        if(PATTERNS.NAME.test(id)) jobs.push(initNode(n,"name"));
        else if(PATTERNS.MAIN.test(id)) jobs.push(initNode(n,"main"));
        else if(PATTERNS.MULTI.test(id)) jobs.push(initNode(n,"multi"));
        else if(PATTERNS.STYLES.test(id)) jobs.push(initNode(n,"styles"));
      }
      await Promise.allSettled(jobs);
    }

    if(document.readyState==="loading") document.addEventListener("DOMContentLoaded", initAll);
    else initAll();
  })();
  </script>
</body>
</html>
