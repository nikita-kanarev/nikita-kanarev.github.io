<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fontsampler Auto Init — Universal Demo</title>
  <!-- Include fontsampler core -->
  <script src="https://nikita-kanarev.github.io/fontsampler.js"></script>
  <script src="https://nikita-kanarev.github.io/fontsampler-skin.js"></script>
  <link rel="stylesheet" href="https://nikita-kanarev.github.io/fontsampler-skin.css" />
  
  <style>
    /* Minimal styling */
    body { 
      font-family: monospace; 
      margin: 20px; 
      line-height: 1.4;
    }
    
    .fsx-section { 
      margin-bottom: 40px; 
      max-width: 1200px;
    }
    
    .fsx-title { 
      margin: 20px 0 10px 0; 
      font-size: 14px;
      font-weight: bold;
    }
    
    /* Named instances display */
    .fsx-instances { 
      margin: 20px 0;
      padding-top: 10px;
      border-top: 1px solid #ccc;
    }
    
    .fsx-instance-row {
      margin: 10px 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .fsx-instance-label {
      width: 120px;
      font-size: 12px;
      flex-shrink: 0;
    }
    
    .fsx-instance-sample {
      font-size: 88px;  /* крупные мини-пробы */
      line-height: 1;
      margin-left: 10px;
      min-width: 200px;
    }

    /* важно: корень мини-инстанса в одну строку, чтобы не ломать флекс */
    .fsx-instance-row .fsjs-root { 
      display: inline-block; 
    }
    
    /* Style testers */
    .fsx-style-item { 
      margin: 20px 0; 
    }
    
    .fsx-style-name { 
      font-size: 12px;
      margin: 5px 0; 
      font-weight: bold;
    }
    
    /* Error display */
    .fsx-error {
      color: red;
      border: 1px solid red;
      padding: 10px;
      margin: 10px 0;
      font-size: 12px;
    }

    /* name_* — без контролов, фиксируем размер 220px */
    [id^="name_"] .fsjs-control-group { display: none !important; }
    [id^="name_"] .fsjs-tester { font-size: 220px; line-height: 1; }

    /* убрать контролы у мини-проб инстансов в блоке main_sampler_* */
    .fsx-instances .fsjs-control-fontsize,
    .fsx-instances .fsjs-control-opentype,
    .fsx-instances .fsjs-control-axis {
      display: none !important;
    }
  </style>
</head>
<body>

  <!-- Demo HTML Markup -->
  <!-- Multiple fonts can be used on the same page -->
  
  <div class="fsx-section">
    
    <h2>Name</h2>
    <div id="name_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
    
    <h2>Main Sampler</h2>
    <div id="main_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
    
    <h2>Sampler</h2>
    <div id="sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>
    
    <h2>Styles Sampler</h2>    
    <div id="styles_sampler_archaism" data-font="https://nikita-kanarev.github.io/Archaism.woff2"></div>

  </div>


  <div class="fsx-section">
    
    <h2>Name</h2>
    <div id="name_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>
    
    <h2>Main Sampler</h2>
    <div id="main_sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>
    
    <h2>Sampler</h2>
    <div id="sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>
    
    <h2>Styles Sampler</h2>    
    <div id="styles_sampler_intervariable" data-font="https://nikita-kanarev.github.io/InterVariable.woff2"></div>

  </div>
  
  <!-- Auto Initializer Script -->
  <script>
  (function () {
    "use strict";

    // ID patterns for different tester types
    const PATTERNS = {
      NAME: /^name_(.+)$/,
      MAIN: /^main_sampler_(.+)$/,
      MULTI: /^sampler_(.+)$/,
      STYLES: /^styles_sampler_(.+)$/
    };

    function resolveMetaUrl(fontUrl) {
      if (!fontUrl) return null;
      try {
        const url = new URL(fontUrl, document.baseURI);
        const pathname = url.pathname;
        const jsonPath = pathname.replace(/\.[^.]+$/, ".json");
        return url.origin + jsonPath + url.search + url.hash;
      } catch (e) {
        return fontUrl.replace(/\.[^.]+$/, ".json");
      }
    }

    async function loadMeta(metaUrl) {
      const fail = (msg) => ({ error: true, message: msg });
      if (!metaUrl) return fail("No metadata URL provided");
      try {
        const res = await fetch(metaUrl, { credentials: "same-origin" });
        if (!res.ok) return fail(\`Failed to load metadata: \${res.status} \${res.statusText}\`);
        const json = await res.json();
        if (!json || (!json.files && !Array.isArray(json.files))) {
          return fail("Invalid metadata: missing 'files' property");
        }
        if (typeof json.files === 'string') json.files = [json.files];
        return json;
      } catch (err) {
        return fail(\`Metadata fetch error: \${err.message || err}\`);
      }
    }

    function buildFonts(meta, instanceOverride = null) {
      const base = { 
        name: meta.name || "Unknown Font", 
        files: meta.files 
      };
      if (instanceOverride) base.instance = instanceOverride;
      return [base];
    }

    function buildOptions(
      meta,
      {
        multiline = true,
        initialText = "",
        sizePx = 38,
        readonly = false,
        showSize = false,
        includeFeatures = true,
        includeAxes = true
      } = {}
    ) {
      const order = [];
      const config = {};

      // Content area (tester)
      order.push("tester");
      config.tester = { editable: !readonly, label: false };

      // Size control (optional)
      if (showSize) {
        order.unshift(["fontsize"]);
        config.fontsize = { 
          unit: "px", init: sizePx, min: 8, max: 256, step: 1, label: "Size" 
        };
      }

      // OpenType features (optional)
      if (includeFeatures && Array.isArray(meta.features) && meta.features.length) {
        order.push(["opentype"]);
        config.opentype = { 
          choices: meta.features, 
          init: meta.features.includes('liga') ? ['liga'] : [], 
          label: "Features" 
        };
      }

      // Variable font axes (optional)
      if (includeAxes && Array.isArray(meta.axes) && meta.axes.length) {
        const axisRow = [];
        for (const axis of meta.axes) {
          const tag = axis.tag;
          axisRow.push(tag);
          config[tag] = {
            init: typeof axis.default === "number" ? axis.default : axis.min,
            min: axis.min,
            max: axis.max,
            step: axis.step || 1,
            label: axis.label || tag.toUpperCase()
          };
        }
        if (axisRow.length) order.push(axisRow);
      }

      return {
        initialText,
        multiline,
        lazyload: false,
        order,
        config,
        classes: { rootClass: "fsjs-skin" }
      };
    }

    // --- helper: из объекта инстанса -> строка CSS font-variation-settings
    function instanceToVarSettings(instanceObj) {
      if (!instanceObj) return "";
      return Object.entries(instanceObj)
        .map(([tag, value]) => \`'\${tag}' \${value}\`)
        .join(", ");
    }

    function showError(node, message) {
      const el = document.createElement("div");
      el.className = "fsx-error";
      el.setAttribute("role", "alert");
      el.textContent = \`Error: \${message}\`;
      node.appendChild(el);
    }

    function createNamedInstancesDisplay(container, instances, meta) {
      if (!instances || !instances.length) return;
      
      const instancesContainer = document.createElement("div");
      instancesContainer.className = "fsx-instances";
      
      const title = document.createElement("div");
      title.textContent = "Named Instances:";
      title.style.cssText = "font-size: 12px; font-weight: bold; margin-bottom: 10px;";
      instancesContainer.appendChild(title);
      
      for (const inst of instances) {
        const row = document.createElement("div");
        row.className = "fsx-instance-row";
        
        const label = document.createElement("span");
        label.className = "fsx-instance-label";
        label.textContent = \`\${inst.name}:\`;
        
        const sample = document.createElement("div");
        sample.className = "fsx-instance-sample";

        const instanceOptions = {
          initialText: inst.name,
          multiline: false,
          lazyload: false,
          config: { tester: { editable: false, label: false } },
          order: ["tester"],
          classes: { rootClass: "fsjs-skin" }
        };
        
        try {
          const fonts = buildFonts(meta, inst.instance);
          const fs = new Fontsampler(sample, fonts, instanceOptions);
          FontsamplerSkin(fs);
          fs.init();

          // Применяем вариативные оси из JSON и удаляем навязанные инлайновые font-style/weight
          const testerEl = sample.querySelector(".fsjs-tester");
          if (testerEl) {
            testerEl.style.fontVariationSettings = instanceToVarSettings(inst.instance);
            testerEl.style.removeProperty("font-weight");
            testerEl.style.removeProperty("font-style");
          }

          const root = sample.querySelector(".fsjs-root");
          if (root) root.style.display = "inline-block";
        } catch (err) {
          sample.textContent = \`Error: \${err.message}\`;
          sample.style.color = "red";
        }
        
        row.appendChild(label);
        row.appendChild(sample);
        instancesContainer.appendChild(row);
      }
      
      container.appendChild(instancesContainer);
    }

    async function initNode(node, type) {
      const fontUrl = node.getAttribute("data-font");
      if (!fontUrl) { showError(node, "Missing data-font attribute"); return; }
      
      const metaUrl = node.getAttribute("data-meta") || resolveMetaUrl(fontUrl);
      const meta = await loadMeta(metaUrl);
      if (meta.error) { showError(node, meta.message); return; }

      try {
        switch (type) {
          case "name": {
            // Readonly name display (фикс. размер 220px через CSS)
            const nameOptions = {
              initialText: meta.name || "Font Name",
              multiline: false,
              lazyload: false,
              config: { tester: { editable: false, label: false } },
              order: ["tester"],
              classes: { rootClass: "fsjs-skin" }
            };
            const nameFs = new Fontsampler(node, buildFonts(meta), nameOptions);
            FontsamplerSkin(nameFs);
            nameFs.init();
            // оставляем как есть; поведение Name не меняем
            break;
          }

          case "main": {
            const mainOptions = buildOptions(meta, { 
              multiline: false, 
              initialText: "Type here", 
              sizePx: 180, 
              readonly: false,
              showSize: false,
              includeFeatures: true,
              includeAxes: true
            });
            const mainFs = new Fontsampler(node, buildFonts(meta), mainOptions);
            FontsamplerSkin(mainFs);
            mainFs.init();
            setTimeout(() => {
              createNamedInstancesDisplay(node, meta.instances, meta);
            }, 100);
            break;
          }

          case "multi": {
            const multiOptions = buildOptions(meta, { 
              multiline: true, 
              initialText: "Multi-line text here...\nType more text to test the font.", 
              sizePx: 24, 
              readonly: false,
              showSize: true,
              includeFeatures: true,
              includeAxes: true
            });
            const multiFs = new Fontsampler(node, buildFonts(meta), multiOptions);
            FontsamplerSkin(multiFs);
            multiFs.init();
            break;
          }

          case "styles": {
            // Только размер; без OpenType и осей в UI, но оси инстанса применяем явно
            const instances = Array.isArray(meta.instances) ? meta.instances : [];
            if (!instances.length) { showError(node, "No named instances defined in metadata"); return; }
            
            for (const inst of instances) {
              const wrapper = document.createElement("div");
              wrapper.className = "fsx-style-item";
              
              const label = document.createElement("div");
              label.className = "fsx-style-name";
              label.textContent = inst.name;
              
              const mount = document.createElement("div");
              
              wrapper.appendChild(label);
              wrapper.appendChild(mount);
              node.appendChild(wrapper);

              const styleOptions = buildOptions(meta, { 
                multiline: false, 
                initialText: inst.name, 
                sizePx: 32, 
                readonly: false,
                showSize: true,
                includeFeatures: false,
                includeAxes: false
              });
              
              const styleFs = new Fontsampler(mount, buildFonts(meta, inst.instance), styleOptions);
              FontsamplerSkin(styleFs);
              styleFs.init();

              // Применяем вариативные оси из JSON и удаляем навязанные инлайновые font-style/weight
              const testerEl = mount.querySelector(".fsjs-tester");
              if (testerEl) {
                testerEl.style.fontVariationSettings = instanceToVarSettings(inst.instance);
                testerEl.style.removeProperty("font-weight");
                testerEl.style.removeProperty("font-style");
              }
            }
            break;
          }
        }
      } catch (err) {
        showError(node, \`Fontsampler initialization failed: \${err.message}\`);
      }
    }

    async function initAll() {
      const nodes = Array.from(document.querySelectorAll("div[id]"));
      const jobs = [];

      for (const node of nodes) {
        const id = node.id;
        if (PATTERNS.NAME.test(id)) {
          jobs.push(initNode(node, "name"));
        } else if (PATTERNS.MAIN.test(id)) {
          jobs.push(initNode(node, "main"));
        } else if (PATTERNS.MULTI.test(id)) {
          jobs.push(initNode(node, "multi"));
        } else if (PATTERNS.STYLES.test(id)) {
          jobs.push(initNode(node, "styles"));
        }
      }
      await Promise.allSettled(jobs);
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initAll);
    } else {
      initAll();
    }
  })();
  </script>

  <!-- 
  Пример JSON:
  {
    "name": "Archaism",
    "files": "https://nikita-kanarev.github.io/Archaism.woff2",
    "axes": [
      { "tag": "wdth", "min": 0, "max": 100, "default": 50, "step": 1, "label": "Width" },
      { "tag": "cntr", "min": 0, "max": 2, "default": 1, "step": 1, "label": "Contrast" }
    ],
    "features": ["liga", "dlig", "ss01", "onum"],
    "instances": [
      { "name": "Wd100Ct0", "instance": { "wdth": 100, "cntr": 0 } },
      { "name": "Wd500Ct2", "instance": { "wdth": 50, "cntr": 2 } },
      { "name": "Wd0Ct1", "instance": { "wdth": 0, "cntr": 1 } }
    ]
  }
  -->
</body>
</html>
